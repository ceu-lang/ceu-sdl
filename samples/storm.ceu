#include "c.ceu"
#include "sdl/sdl.ceu"

#define WIN_W 640
#define WIN_H 480

#define PI 3.14159265

#define DROPS_PERSEC_MIN  10
#define DROPS_PERSEC_MAX 100
#define DROPS_DECAY_MS 2000

data Vector2D with
    var int x,y;
end;

data Axis with
    var float pos;
    var int   len;
    var float vel;
    var float acc;
    var float drag;
end

data IPhysics with
    var Axis x;
    var Axis y;
    var SDL_Color clr;
end

var& _SDL_Renderer_ptr ren;
watching SDL_go("Storm", WIN_W, WIN_H, SDL_Color(0x21,0x2c,0x34,0x00))
            => (ren)
do
code/await Physics (var SDL_Rect rct, var SDL_Color clr)
                    => (var& IPhysics physics)
                        => void
do
    var IPhysics phys_ = val IPhysics(
                                Axis(rct.x, rct.w, 0, 0, 0),
                                Axis(rct.y, rct.h, 0, 0, 0),
                                clr,
                             );
    physics = &phys_;

    par do
        var int dt_ = _;
        every dt_ in SDL_DT do
            var float dt = (dt_ as float)/1000;
            phys_.x.vel = (phys_.x.vel + phys_.x.acc*dt)
                            * (1 - phys_.x.drag*dt);
            phys_.y.vel = (phys_.y.vel + phys_.y.acc*dt)
                            * (1 - phys_.y.drag*dt);
            phys_.x.pos = phys_.x.pos + phys_.x.vel*dt;
            phys_.y.pos = phys_.y.pos + phys_.y.vel*dt;
        end
    with
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(outer.ren,
                                    phys_.clr.r,
                                    phys_.clr.g,
                                    phys_.clr.b,
                                    phys_.clr.a);
            var SDL_Rect r = val SDL_Rect(phys_.x.pos as int,
                                          phys_.y.pos as int,
                                          phys_.x.len as int,
                                          phys_.y.len as int);
            _SDL_RenderFillRect(outer.ren, (&&r as _SDL_Rect&&));
        end
    end
end

#define DROP_LEN 2

code/await Drop (var& IPhysics cloud) => void
do
    var SDL_Rect rct = val SDL_Rect((_rand()%cloud.x.len + cloud.x.pos) as int,
                                    (cloud.y.pos + cloud.y.len) as int,
                                    DROP_LEN,
                                    5);
    var& IPhysics drop;
    watching Physics(rct, SDL_Color(0x98, 0xC1, 0xE4, 0))
                => (drop)
    do
        drop.x.vel  = cloud.x.vel;
        drop.x.drag = 0.98;
        drop.y.drag = 0.98;
        drop.y.acc  = 500;

        event void decay;
        par/or do
            loop do
                var int dt = await SDL_DT;
                if drop.y.pos > WIN_H-DROP_LEN then
                    drop.y.pos = WIN_H-DROP_LEN;
                    drop.y.vel = -(drop.y.vel*2/3);
                    emit decay;
                end
                if (drop.x.pos > WIN_W) or (drop.y.pos < 0) or (drop.x.pos < 0) then
                    escape;
                end

                var int abs_vx = _abs(drop.x.vel);
                var int abs_vy = _abs(drop.y.vel);
                if abs_vx > abs_vy then
                    drop.x.len = DROP_LEN * (1 + (abs_vx-abs_vy)/100);
                    drop.y.len = DROP_LEN;
                else
                    drop.x.len = DROP_LEN;
                    drop.y.len = DROP_LEN * (1 + (abs_vy-abs_vx)/100);
                end

                var int tmax = DROP_LEN * 4;
                if drop.x.len > tmax then
                    drop.x.len = tmax;
                end
                if drop.y.len > tmax then
                    drop.y.len = tmax;
                end
            end
        with
            await decay;
            await (DROPS_DECAY_MS)ms;
        end
    end
end

code/await Cloud (var int dps) => (var& int dps_out) => void
do
    pool[] Drop drops;

    dps_out = &dps;

    var int maxy = 2 * 1000 / DROPS_PERSEC_MIN;

    var int freq_ini = 1000 / dps;
    var int freq_cur = freq_ini;
    var int ty = maxy - freq_cur*2;
    if ty < 1 then
        ty = 1;
    end

    var int w = 100 + _rand()%100;
    var SDL_Rect rct = val SDL_Rect(-w, ty, 100+_rand()%100, 20+_rand()%50);

    var int v = 200 - (200*ty / maxy);
    var SDL_Color clr = val SDL_Color(v, (v*0.95) as int, v, 0);

    var int vx = 10 + _rand()%50;

    var& IPhysics cloud;
    watching Physics(rct, clr) => (cloud)
    do
        cloud.x.vel = vx;
        par do
            var int dt;
            every dt in SDL_DT do
                if cloud.x.pos > WIN_W then
                    cloud.x.pos = -cloud.x.len;
                end
            end
        with
            every (freq_cur)ms do
                spawn Drop(&cloud) in drops;
            end
        with
            loop do
                await 50ms;
                freq_ini = 1000 / dps;
                if freq_ini == freq_cur then
                    continue;
                end

                if _abs(freq_ini - freq_cur) < 1 then
                    freq_cur = freq_ini;
                else/if (freq_ini - freq_cur) > 0 then
                    freq_cur = freq_cur + 1;
                else
                    freq_cur = freq_cur - 1;
                end

                ty = maxy - freq_cur*2;
                if ty < 1 then
                    ty = 1;
                end
                cloud.y.pos = ty;
                cloud.clr = val SDL_Color(200-(200*ty/maxy),
                                          ((cloud.clr.r as int)*0.95) as u8,
                                          cloud.clr.r,
                                          cloud.clr.a);
            end
        end
    end
end

code/await Storm (void) => void
do
    pool[] Cloud clouds;

    var int dps_cur = 0;

    loop i in [0 -> 3[ do
        var int dps = (_rand() % (DROPS_PERSEC_MAX-dps_cur)) + DROPS_PERSEC_MIN;
        if dps < 0 then
            dps = 1;
        end
        dps_cur = dps_cur + dps;

        spawn Cloud(dps) in clouds;
    end

        every 1s do
            var& int dps_cloud;
            loop (dps_cloud) in clouds do
                if _rand()%3 > 0 then
                    dps_cur = dps_cur - dps_cloud;
                    if dps_cur > DROPS_PERSEC_MAX then
                        dps_cur = DROPS_PERSEC_MAX;
                    else/if dps_cur < DROPS_PERSEC_MIN then
                        dps_cur = DROPS_PERSEC_MIN;
                    end

                    var int dps = _rand()%(DROPS_PERSEC_MAX+1-dps_cur) + DROPS_PERSEC_MIN;
                    if dps < 0 then
                        dps = 1;
                    end
                    dps_cur = dps_cur + dps;
                    dps_cloud = dps;
                end
            end
            _printf("\nGotas por Segundo atual: %d/%d\n",dps_cur,DROPS_PERSEC_MAX);
        end
end

code/await Wheel (var& IPhysics car, var Vector2D offset) => void
do
    var int radius = 15;
    var float esp = (2 * PI / 12);
    var float pos = 0;

    par do
        var int dt = _;
        every dt in SDL_DT do
            var int s = do
                if car.x.vel >= 0 then
                    escape  1;
                else
                    escape -1;
                end
            end;

            var float mod = _sqrt(_pow(car.x.vel,2) + _pow(car.y.vel,2));
            pos = pos + (s * mod * dt / 1000 / radius);
        end
    with
        every SDL_REDRAW do
            _SDL_SetRenderDrawColor(outer.ren, 0xFF, 0x9D, 0x46, 0x00);
            loop i in [0 -> 12[ do
                var SDL_Rect r =
                    val SDL_Rect(
                        (car.x.pos + offset.x + (radius * _cos(i*esp + pos))) as int,
                        (car.y.pos + offset.y + (radius * _sin(i*esp + pos))) as int,
                        5, 5
                    );
                _SDL_RenderFillRect(outer.ren, (&&r as _SDL_Rect&&));
            end
        end
    end
end

code/await Car (void) => void
do
    var& IPhysics car;
    watching Physics(SDL_Rect(320,430, 60,30), SDL_Color(0x3B,0xBC,0x48,0))
                => (car)
    do
        spawn Wheel(&car, Vector2D(        0, car.y.len));
        spawn Wheel(&car, Vector2D(car.x.len, car.y.len));

        car.x.drag = 0.95;
        car.y.drag = 0.95;

        par do
            loop do
                var _SDL_KeyboardEvent&& key;
                key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_LEFT;
                car.x.acc = -400;
                key = await SDL_KEYUP   until key:keysym.sym==_SDLK_LEFT;
                car.x.acc = 0;
            end
        with
            loop do
                var _SDL_KeyboardEvent&& key;
                key = await SDL_KEYDOWN until key:keysym.sym==_SDLK_RIGHT;
                car.x.acc = 400;
                key = await SDL_KEYUP   until key:keysym.sym==_SDLK_RIGHT;
                car.x.acc = 0;
            end
        end
    end
end

    spawn Car();
    spawn Storm();

    await FOREVER;
end

escape 0;
